/* tslint:disable */
/* eslint-disable */
/**
*/
export function init(): void;
/**
* The Authorizer verifies a request according to its policies and the provided token
*/
export class Authorizer {
  free(): void;
/**
*/
  constructor();
/**
* @param {Biscuit} token
*/
  addToken(token: Biscuit): void;
/**
* Adds a Datalog fact
* @param {Fact} fact
*/
  addFact(fact: Fact): void;
/**
* Adds a Datalog rule
* @param {Rule} rule
*/
  addRule(rule: Rule): void;
/**
* Adds a check
*
* All checks, from authorizer and token, must be validated to authorize the request
* @param {Check} check
*/
  addCheck(check: Check): void;
/**
* Adds a policy
*
* The authorizer will test all policies in order of addition and stop at the first one that
* matches. If it is a "deny" policy, the request fails, while with an "allow" policy, it will
* succeed
* @param {Policy} policy
*/
  addPolicy(policy: Policy): void;
/**
* Merges the contents of another authorizer
* @param {Authorizer} other
*/
  merge(other: Authorizer): void;
/**
* Merges the contents of a block builder
* @param {BlockBuilder} other
*/
  mergeBlock(other: BlockBuilder): void;
/**
* Adds facts, rules, checks and policies as one code block
* @param {string} source
*/
  addCode(source: string): void;
/**
* Adds facts, rules, checks and policies as one code block
* @param {string} source
* @param {any} parameters
* @param {any} scope_parameters
*/
  addCodeWithParameters(source: string, parameters: any, scope_parameters: any): void;
/**
* Runs the authorization checks and policies
*
* Returns the index of the matching allow policy, or an error containing the matching deny
* policy or a list of the failing checks
* @returns {number}
*/
  authorize(): number;
/**
* @param {any} limits
* @returns {number}
*/
  authorizeWithLimits(limits: any): number;
/**
* Executes a query over the authorizer
* @param {Rule} rule
* @returns {Array<any>}
*/
  query(rule: Rule): Array<any>;
/**
* Executes a query over the authorizer
* @param {Rule} rule
* @param {any} limits
* @returns {Array<any>}
*/
  queryWithLimits(rule: Rule, limits: any): Array<any>;
/**
* @returns {string}
*/
  toString(): string;
}
/**
* a Biscuit token
*
* it can produce an attenuated or sealed token, or be used
* in an authorizer along with Datalog policies
*/
export class Biscuit {
  free(): void;
/**
* Creates a BiscuitBuilder
*
* the builder can then create a new token with a root key
* @returns {BiscuitBuilder}
*/
  static builder(): BiscuitBuilder;
/**
* Creates a BlockBuilder
*
* the builder can be merged with a `BiscuitBuilder`, another `BlockBuilder`,
* and used to append a block to a biscuit
* @returns {BlockBuilder}
*/
  static block_builder(): BlockBuilder;
/**
* Creates an attenuated token by adding the block generated by the BlockBuilder
* @param {BlockBuilder} block
* @returns {Biscuit}
*/
  appendBlock(block: BlockBuilder): Biscuit;
/**
* Creates an authorizer from the token
* @returns {Authorizer}
*/
  getAuthorizer(): Authorizer;
/**
* Seals the token
*
* A sealed token cannot be attenuated
* @returns {Biscuit}
*/
  sealToken(): Biscuit;
/**
* Deserializes a token from raw data
*
* This will check the signature using the root key
* @param {Uint8Array} data
* @param {PublicKey} root
* @returns {Biscuit}
*/
  static fromBytes(data: Uint8Array, root: PublicKey): Biscuit;
/**
* Deserializes a token from URL safe base 64 data
*
* This will check the signature using the root key
* @param {string} data
* @param {PublicKey} root
* @returns {Biscuit}
*/
  static fromBase64(data: string, root: PublicKey): Biscuit;
/**
* Serializes to raw data
* @returns {Uint8Array}
*/
  toBytes(): Uint8Array;
/**
* Serializes to URL safe base 64 data
* @returns {string}
*/
  toBase64(): string;
/**
* Returns the list of revocation identifiers, encoded as URL safe base 64
* @returns {any[]}
*/
  getRevocationIdentifiers(): any[];
/**
* Returns the number of blocks in the token
* @returns {number}
*/
  countBlocks(): number;
/**
* Prints a block's content as Datalog code
* @param {number} index
* @returns {string}
*/
  getBlockSource(index: number): string;
/**
* Creates a third party request
* @returns {ThirdPartyRequest}
*/
  getThirdPartyRequest(): ThirdPartyRequest;
/**
* Appends a third party block and returns a new token
* @param {PublicKey} external_key
* @param {ThirdPartyBlock} block
* @returns {Biscuit}
*/
  appendThirdPartyBlock(external_key: PublicKey, block: ThirdPartyBlock): Biscuit;
/**
* @returns {string}
*/
  toString(): string;
}
/**
* Creates a token
*/
export class BiscuitBuilder {
  free(): void;
/**
*/
  constructor();
/**
* @param {PrivateKey} root
* @returns {Biscuit}
*/
  build(root: PrivateKey): Biscuit;
/**
* adds the content of an existing `BlockBuilder`
* @param {BlockBuilder} other
*/
  merge(other: BlockBuilder): void;
/**
* Adds a Datalog fact
* @param {Fact} fact
*/
  addFact(fact: Fact): void;
/**
* Adds a Datalog rule
* @param {Rule} rule
*/
  addRule(rule: Rule): void;
/**
* Adds a check
*
* All checks, from authorizer and token, must be validated to authorize the request
* @param {Check} check
*/
  addCheck(check: Check): void;
/**
* Adds facts, rules, checks and policies as one code block
* @param {string} source
*/
  addCode(source: string): void;
/**
* Adds facts, rules, checks and policies as one code block
* @param {string} source
* @param {any} parameters
* @param {any} scope_parameters
*/
  addCodeWithParameters(source: string, parameters: any, scope_parameters: any): void;
/**
* @returns {string}
*/
  toString(): string;
}
/**
* Creates a block to attenuate a token
*/
export class BlockBuilder {
  free(): void;
/**
* creates a BlockBuilder
*
* the builder can then be given to the token's append method to create an attenuated token
*/
  constructor();
/**
* Adds a Datalog fact
* @param {Fact} fact
*/
  addFact(fact: Fact): void;
/**
* Adds a Datalog rule
* @param {Rule} rule
*/
  addRule(rule: Rule): void;
/**
* Adds a check
*
* All checks, from authorizer and token, must be validated to authorize the request
* @param {Check} check
*/
  addCheck(check: Check): void;
/**
* Adds facts, rules, checks and policies as one code block
* @param {string} source
*/
  addCode(source: string): void;
/**
* Adds facts, rules, checks and policies as one code block
* @param {string} source
* @param {any} parameters
* @param {any} scope_parameters
*/
  addCodeWithParameters(source: string, parameters: any, scope_parameters: any): void;
/**
* @returns {string}
*/
  toString(): string;
}
/**
*/
export class Check {
  free(): void;
/**
* @param {string} source
* @returns {Check}
*/
  static fromString(source: string): Check;
/**
* @returns {Array<any>}
*/
  unboundParameters(): Array<any>;
/**
* @returns {Array<any>}
*/
  unboundScopeParameters(): Array<any>;
/**
* @param {string} name
* @param {any} value
*/
  set(name: string, value: any): void;
/**
* @param {string} name
* @param {any} value
*/
  setScope(name: string, value: any): void;
/**
* @returns {string}
*/
  toString(): string;
}
/**
*/
export class Fact {
  free(): void;
/**
* @param {string} source
* @returns {Fact}
*/
  static fromString(source: string): Fact;
/**
* @returns {Array<any>}
*/
  unboundParameters(): Array<any>;
/**
* @param {string} name
* @param {any} value
*/
  set(name: string, value: any): void;
/**
* @returns {string}
*/
  toString(): string;
}
/**
* A pair of public and private key
*/
export class KeyPair {
  free(): void;
/**
*/
  constructor();
/**
* @param {PrivateKey} key
* @returns {KeyPair}
*/
  static fromPrivateKey(key: PrivateKey): KeyPair;
/**
* @returns {PublicKey}
*/
  getPublicKey(): PublicKey;
/**
* @returns {PrivateKey}
*/
  getPrivateKey(): PrivateKey;
}
/**
*/
export class Policy {
  free(): void;
/**
* @param {string} source
* @returns {Policy}
*/
  static fromString(source: string): Policy;
/**
* @returns {Array<any>}
*/
  unboundParameters(): Array<any>;
/**
* @returns {Array<any>}
*/
  unboundScopeParameters(): Array<any>;
/**
* @param {string} name
* @param {any} value
*/
  set(name: string, value: any): void;
/**
* @param {string} name
* @param {any} value
*/
  setScope(name: string, value: any): void;
/**
* @returns {string}
*/
  toString(): string;
}
/**
*/
export class PrivateKey {
  free(): void;
/**
* Serializes a private key to raw bytes
* @param {Uint8Array} out
*/
  toBytes(out: Uint8Array): void;
/**
* Serializes a private key to a hexadecimal string
* @returns {string}
*/
  toString(): string;
/**
* Deserializes a private key from raw bytes
* @param {Uint8Array} data
* @returns {PrivateKey}
*/
  static fromBytes(data: Uint8Array): PrivateKey;
/**
* Deserializes a private key from a hexadecimal string
* @param {string} data
* @returns {PrivateKey}
*/
  static fromString(data: string): PrivateKey;
}
/**
* Public key
*/
export class PublicKey {
  free(): void;
/**
* Serializes a public key to raw bytes
* @param {Uint8Array} out
*/
  toBytes(out: Uint8Array): void;
/**
* Serializes a public key to a hexadecimal string
* @returns {string}
*/
  toString(): string;
/**
* Serializes a public key to a string usable as a datalog parameter
* @returns {string}
*/
  toDatalogParameter(): string;
/**
* Deserializes a public key from raw bytes
* @param {Uint8Array} data
* @returns {PublicKey}
*/
  static fromBytes(data: Uint8Array): PublicKey;
/**
* Deserializes a public key from a hexadecimal string
* @param {string} data
* @returns {PublicKey}
*/
  static fromString(data: string): PublicKey;
}
/**
*/
export class Rule {
  free(): void;
/**
* @param {string} source
* @returns {Rule}
*/
  static fromString(source: string): Rule;
/**
* @returns {Array<any>}
*/
  unboundParameters(): Array<any>;
/**
* @returns {Array<any>}
*/
  unboundScopeParameters(): Array<any>;
/**
* @param {string} name
* @param {any} value
*/
  set(name: string, value: any): void;
/**
* @param {string} name
* @param {any} value
*/
  setScope(name: string, value: any): void;
/**
* @returns {string}
*/
  toString(): string;
}
/**
*/
export class ThirdPartyBlock {
  free(): void;
/**
* Deserializes a third party request from raw data
* @param {Uint8Array} data
* @returns {ThirdPartyRequest}
*/
  static fromBytes(data: Uint8Array): ThirdPartyRequest;
/**
* Deserializes a third party request from URL safe base 64 data
*
* This will check the signature using the root key
* @param {string} data
* @returns {ThirdPartyRequest}
*/
  static fromBase64(data: string): ThirdPartyRequest;
/**
* Serializes to raw data
* @returns {Uint8Array}
*/
  toBytes(): Uint8Array;
/**
* Serializes to URL safe base 64 data
* @returns {string}
*/
  toBase64(): string;
}
/**
* Creates a block to attenuate a token
*/
export class ThirdPartyRequest {
  free(): void;
/**
* Deserializes a third party request from raw data
* @param {Uint8Array} data
* @returns {ThirdPartyRequest}
*/
  static fromBytes(data: Uint8Array): ThirdPartyRequest;
/**
* Deserializes a third party request from URL safe base 64 data
*
* This will check the signature using the root key
* @param {string} data
* @returns {ThirdPartyRequest}
*/
  static fromBase64(data: string): ThirdPartyRequest;
/**
* Serializes to raw data
* @returns {Uint8Array}
*/
  toBytes(): Uint8Array;
/**
* Serializes to URL safe base 64 data
* @returns {string}
*/
  toBase64(): string;
/**
* creates a ThirdPartyBlock from a BlockBuilder and the
* third party service's private key
* @param {PrivateKey} private_key
* @param {BlockBuilder} block_builder
* @returns {ThirdPartyBlock}
*/
  createBlock(private_key: PrivateKey, block_builder: BlockBuilder): ThirdPartyBlock;
}
/**
 * Function building an authorizer from a request, or an authorizer directly,
 * when it doesn't depend on the request
 */
export type AuthorizerBuilder = Authorizer | ((req: any) => Authorizer);

/**
 * Phase of the authorization process where the error happened.
 * Extraction is extracting a token string from the HTTP request.
 * Verification is parsing and verifying a token cryptographic integrity.
 * Authorization is making sure the token grants sufficient rights for the request.
 */
export type ErrorType = "extraction" | "verification" | "authorization";

/**
 * Phase of the authorization process where the error happened.
 * Extraction is extracting a token string from the HTTP request.
 * Verification is parsing and verifying a token cryptographic integrity.
 * Authorization is making sure the token grants sufficient rights for the request.
 */
export type BiscuitMiddlewareOptions = {
  /**
   * Public key used to verify the token signatures
   */
  publicKey: PublicKey;
  /**
   * Authorizer policies which will be evaluated before the per-endpoint policies
   */
  priorityAuthorizer: AuthorizerBuilder;
  /**
   * Authorizer policies which will be evaluated after the per-endpoint policies
   */
  fallbackAuthorizer: AuthorizerBuilder;
  /**
   * Custom function for extracting the token string from the request. The default
   * behaviour expects an `Authorization: Bearer` header.
   */
  tokenExtractor: (request: any) => string;
  /**
   * Custom function for parsing and verifying the token. The default behaviour
   * expects a URL-safe-base64-encoded token and will use the provided public
   * key.
   */
  tokenParser: (tokenString: string, publicKey: PublicKey) => Biscuit;

  /**
   * Error handler called when the authorization process fails. The default
   * behaviour logs the error and sends an HTTP error response.
   */
  onError: (
    errorType: ErrorType,
    error: any,
    req: any,
    res: any,
    next: any
  ) => void;
};

export function middleware(
  options: BiscuitMiddlewareOptions
): (
  makeAuthorizer: AuthorizerBuilder
) => (req: any, res: any, next: any) => any;
/**
 * Tagged template generating a biscuit builder from datalog code
 *
 * @param {TemplateStringsArray} strings
 * @param {any[]} values
 */
export function biscuit(
  strings: TemplateStringsArray,
  ...values: any[]
): BiscuitBuilder;
/**
 * Tagged template generating a block builder from datalog code
 *
 * @param {TemplateStringsArray} strings
 * @param {any[]} values
 */
export function block(
  strings: TemplateStringsArray,
  ...values: any[]
): BlockBuilder;
/**
 * Tagged template generating an authorizer from datalog code
 *
 * @param {TemplateStringsArray} strings
 * @param {any[]} values
 */
export function authorizer(
  strings: TemplateStringsArray,
  ...values: any[]
): Authorizer;
/**
 * Tagged template generating a fact from datalog code
 *
 * @param {TemplateStringsArray} strings
 * @param {any[]} values
 */
export function fact(strings: TemplateStringsArray, ...values: any[]): Fact;
/**
 * Tagged template generating a rule from datalog code
 *
 * @param {TemplateStringsArray} strings
 * @param {any[]} values
 */
export function rule(strings: TemplateStringsArray, ...values: any[]): Rule;
/**
 * Tagged template generating a check from datalog code
 *
 * @param {TemplateStringsArray} strings
 * @param {any[]} values
 */
export function check(strings: TemplateStringsArray, ...values: any[]): Check;
/**
 * Tagged template generating a policy from datalog code
 *
 * @param {TemplateStringsArray} strings
 * @param {any[]} values
 */
export function policy(strings: TemplateStringsArray, ...values: any[]): Policy;
/**
 * Adapt JS values so they can be deserialized as terms by the wasm
 * module.
 *
 * @param {any} value
 */
export function prepareTerm(value: any): any;
